package app.revanced.extension.youtube.transcripts;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLDecoder;
import java.util.concurrent.TimeUnit;

import app.revanced.extension.shared.Logger;
import app.revanced.extension.shared.requests.Requester;

/**
 * Fetches and parses YouTube video transcripts/captions.
 */
public class TranscriptFetcher {
    private static final String TAG = "TranscriptFetcher";
    private static final int CONNECTION_TIMEOUT_MS = 10000;
    private static final int READ_TIMEOUT_MS = 20000;

    /**
     * Represents a parsed transcript with all text segments combined.
     */
    public static class Transcript {
        public final String text;
        public final String languageCode;
        public final boolean isAutoGenerated;

        public Transcript(@NonNull String text, @NonNull String languageCode, boolean isAutoGenerated) {
            this.text = text;
            this.languageCode = languageCode;
            this.isAutoGenerated = isAutoGenerated;
        }

        @NonNull
        @Override
        public String toString() {
            return "Transcript{" +
                    "length=" + text.length() +
                    ", language='" + languageCode + '\'' +
                    ", autoGenerated=" + isAutoGenerated +
                    '}';
        }
    }

    /**
     * Extract caption track URL from player response JSON.
     * Prioritizes user's language, then falls back to auto-generated captions.
     */
    @Nullable
    public static String extractCaptionUrl(@NonNull String playerResponse, @Nullable String preferredLanguage) {
        try {
            JSONObject response = new JSONObject(playerResponse);
            
            if (!response.has("captions")) {
                Logger.printDebug(() -> TAG + " No captions found in player response");
                return null;
            }

            JSONObject captions = response.getJSONObject("captions");
            if (!captions.has("playerCaptionsTracklistRenderer")) {
                return null;
            }

            JSONObject renderer = captions.getJSONObject("playerCaptionsTracklistRenderer");
            if (!renderer.has("captionTracks")) {
                return null;
            }

            JSONArray captionTracks = renderer.getJSONArray("captionTracks");
            if (captionTracks.length() == 0) {
                return null;
            }

            // First pass: look for exact language match (non-auto-generated preferred)
            String fallbackUrl = null;
            String autoGeneratedUrl = null;

            for (int i = 0; i < captionTracks.length(); i++) {
                JSONObject track = captionTracks.getJSONObject(i);
                String baseUrl = track.optString("baseUrl", "");
                String languageCode = track.optString("languageCode", "");
                boolean isTranslatable = track.optBoolean("isTranslatable", false);
                
                if (baseUrl.isEmpty()) continue;

                // Check if this is auto-generated (kind field present)
                boolean isAutoGenerated = track.has("kind") && 
                    "asr".equals(track.optString("kind", ""));

                // Exact language match
                if (preferredLanguage != null && languageCode.startsWith(preferredLanguage)) {
                    if (!isAutoGenerated) {
                        return baseUrl; // Perfect match: correct language, not auto-generated
                    } else if (autoGeneratedUrl == null) {
                        autoGeneratedUrl = baseUrl; // Store as fallback
                    }
                }

                // Store first non-auto-generated as general fallback
                if (fallbackUrl == null && !isAutoGenerated) {
                    fallbackUrl = baseUrl;
                }

                // Store first auto-generated as last resort
                if (autoGeneratedUrl == null && isAutoGenerated) {
                    autoGeneratedUrl = baseUrl;
                }
            }

            // Return in order of preference
            if (autoGeneratedUrl != null && preferredLanguage != null) {
                return autoGeneratedUrl; // Preferred language auto-generated
            }
            if (fallbackUrl != null) {
                return fallbackUrl; // Any non-auto-generated
            }
            if (autoGeneratedUrl != null) {
                return autoGeneratedUrl; // Any auto-generated
            }

            // If all else fails, return first track URL
            return captionTracks.getJSONObject(0).optString("baseUrl", null);

        } catch (JSONException e) {
            Logger.printException(() -> TAG + " Failed to extract caption URL", e);
            return null;
        }
    }

    /**
     * Fetches transcript from YouTube's timedtext API.
     * @param captionUrl The base URL from player response
     * @return Parsed transcript or null if failed
     */
    @Nullable
    public static Transcript fetchTranscript(@NonNull String captionUrl) {
        try {
            // Ensure we request JSON format
            String url = captionUrl;
            if (!url.contains("fmt=")) {
                url += (url.contains("?") ? "&" : "?") + "fmt=json3";
            }

            Logger.printDebug(() -> TAG + " Fetching transcript from: " + url);

            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
            connection.setRequestMethod("GET");
            connection.setConnectTimeout(CONNECTION_TIMEOUT_MS);
            connection.setReadTimeout(READ_TIMEOUT_MS);
            connection.setRequestProperty("User-Agent", "Mozilla/5.0");

            int responseCode = connection.getResponseCode();
            if (responseCode != 200) {
                Logger.printDebug(() -> TAG + " Failed to fetch transcript. Response code: " + responseCode);
                return null;
            }

            String response = Requester.parseString(connection);
            connection.disconnect();

            return parseTranscriptJson(response);

        } catch (IOException e) {
            Logger.printException(() -> TAG + " Network error fetching transcript", e);
            return null;
        }
    }

    /**
     * Parses JSON3 format transcript from YouTube.
     * Format: {"events": [{"segs": [{"utf8": "text"}]}, ...]}
     */
    @Nullable
    private static Transcript parseTranscriptJson(@NonNull String jsonResponse) {
        try {
            JSONObject root = new JSONObject(jsonResponse);
            
            if (!root.has("events")) {
                Logger.printDebug(() -> TAG + " No events array in transcript JSON");
                return null;
            }

            JSONArray events = root.getJSONArray("events");
            StringBuilder transcriptText = new StringBuilder();
            String languageCode = root.optString("languageCode", "unknown");
            
            for (int i = 0; i < events.length(); i++) {
                JSONObject event = events.getJSONObject(i);
                
                if (!event.has("segs")) {
                    continue; // Skip events without text segments
                }

                JSONArray segments = event.getJSONArray("segs");
                for (int j = 0; j < segments.length(); j++) {
                    JSONObject segment = segments.getJSONObject(j);
                    String text = segment.optString("utf8", "");
                    
                    if (!text.isEmpty()) {
                        transcriptText.append(text);
                        
                        // Don't add space if the text already ends with punctuation or whitespace
                        if (!text.matches(".*[\\s\\p{Punct}]$")) {
                            transcriptText.append(" ");
                        }
                    }
                }
                
                // Add newline between events for better readability
                if (transcriptText.length() > 0 && 
                    transcriptText.charAt(transcriptText.length() - 1) != '\n') {
                    transcriptText.append("\n");
                }
            }

            String finalText = transcriptText.toString().trim();
            if (finalText.isEmpty()) {
                Logger.printDebug(() -> TAG + " Transcript parsing resulted in empty text");
                return null;
            }

            Logger.printDebug(() -> TAG + " Successfully parsed transcript: " + 
                finalText.length() + " chars, language: " + languageCode);

            return new Transcript(finalText, languageCode, false);

        } catch (JSONException e) {
            Logger.printException(() -> TAG + " Failed to parse transcript JSON", e);
            return null;
        }
    }

    /**
     * Convenience method to fetch transcript by video ID.
     * Requires the player response to be available.
     */
    @Nullable
    public static Transcript fetchTranscriptForVideo(@NonNull String videoId, 
                                                     @NonNull String playerResponse, 
                                                     @Nullable String preferredLanguage) {
        String captionUrl = extractCaptionUrl(playerResponse, preferredLanguage);
        if (captionUrl == null) {
            Logger.printDebug(() -> TAG + " No caption URL found for video: " + videoId);
            return null;
        }

        return fetchTranscript(captionUrl);
    }
}
